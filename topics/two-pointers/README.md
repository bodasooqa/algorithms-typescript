# Two Pointers

Работа происходит с **отсортированными** массивами, строками и связанными списками.

### Примеры задач

* Найти пару-тройку в отсортированном массиве по условию (разность, сумма и т.д.).
* Найти середину, начало цикла или цикл в связанном списке.
* Симметричная проверка (полиндромы, зеркала) – сравнение с начала и конца.
* Удалить/сжать дубликаты в отсортированном массиве **in-place**.
* Есть две границы диапазона (макс. площадь, минимальная длина).

### Три основные техники

1. **Opposite Ends**
   
   Изначально есть `left = 0` и `right = length - 1`. Каждую итерацию двигаешь одну из границ друг к другу, сужая область.
2. **Forward Sweep** 
   
   `slow` – валидный результат, `fast` – чтение. Часто подходит для удаления дубликатов, фильтрации (in-place).
3. **Fast/Slow**
   
   Для связанных списков: `fast` шагает на **2**, `slow` на **1**. Их встреча – цикл.

### Шаблоны

#### Opposite Ends

```ts
let left = 0;
let right = arr.length - 1;

while (left < right) {
    if (условие выполнено) // Результат
    else if (надо больше) left++; // Сужаем слева
    else right--; // Сужаем справа
}
```

#### Forward Sweep

```ts
let slow = 0;

for (let fast = 0; fast < arr.length; fast++) {
    if (arr[fast] удовлетворяет критерию) {
        arr[slow] = arr[fast];
        slow++;
    }
}

return slow; // Возвращаем новую длину массива (сам массив мутирован)
```

#### Fast/Slow

```ts
// 1 > 2 > 3 > 4 <-
let slow = head; // head – первый узел связанного списка
let fast = head;

while (fast && fast.next) {
    slow = slow.next; // Один шаг     2 3 4 1
    fast = fast.next.next // Два шага 3 1 3 1

    if (slow === fast) return true; // Цикл обнаруежен
}

return false;
```